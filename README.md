# anything I'm interesting in writing ![alt text](https://jpramos.me/Data/icosi.png)
#### standard date format YYYY.MM.DD

<br>

<h2>
  <a href="http://blog.jpramos.me/2022.07.12" style="color: #364491; border-bottom:1px dotted">
    [2022.06.28] I ♥ Lightweight Formal Methods
  </a>
</h2>

> In <a href="https://assets.amazon.science/77/5e/4a7c238f4ce890efdc325df83263/using-lightweight-formal-methods-to-validate-a-key-value-storage-node-in-amazon-s3-2.pdf" style="color: #364491; border-bottom:1px dotted">Bornholt et al. [2021]</a>, Amazon describes the use of *lightweight formal methods* as a pragmatic approach to verify the correctness of a given production system. I'm interested in this *lightweight* property they present, in which a formal specification doesn't have to be fully achieved, but an emphasizing automation and sustainability through property based testing. Also inspired by the classic Quickcheck (<a href="https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf" style="color: #364491; border-bottom:1px dotted">Claessen and Hughes [2000]</a>) paper.

<br>

<h2>
  <a href="http://blog.jpramos.me/2022.06.28" style="color: #364491; border-bottom:1px dotted">
    [2022.06.28] What is Gradual Verification?
  </a>
</h2>

> Formal verification is a program correctness and soundness verification method that is near and dear to my heart. However, recently I've been working on a research project involving Gradual Verification! Introduced by <a href="http://www.cs.cmu.edu/~aldrich/papers/vmcai2018-gradual-verification.pdf" style="color: #364491; border-bottom:1px dotted">Bader et al. [2018]</a>, GV seeks to use both static and dynamic program verification and make use of their isolated advantages, inspired by gradual typing. I explain at a somewhat high level what GV is technically, why we should care about it, and current systems tools for GV.

<br>

<h2>
  <a href="http://blog.jpramos.me/2022.04.21" style="color: #364491; border-bottom:1px dotted">
    [2022.04.21] A brief explanation of GraphMat and Graphicionado
  </a>
</h2>

> I've recently been working on graph analytic algorithms, or well the optimization of graph algorithms. While working with my current research group (<a href="https://capra.cs.cornell.edu" style="color: #364491; border-bottom:1px dotted">CAPRA</a>) I've been trying to understand our <a href="calyxir.org" style="color: #364491; border-bottom:1px dotted">Calyx compiler infrastructure</a>. What's a better way to learn a language than by using it to implement <a href="https://mrmgroup.cs.princeton.edu/papers/taejun_micro16.pdf" style="color: #364491; border-bottom:1px dotted">a very unintuitive research paper</a>? I go into detail about what exactly Graphicionado is —*in simple terms*—  a graph algorithm optimization framework using hardware.


<br>

<br>

<br>

【<a href="https://jpramos.me" style="color: #8B0000; text-align: right">main site</a>】

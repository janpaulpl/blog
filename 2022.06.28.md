# What is <a href="http://www.cs.cmu.edu/~aldrich/papers/vmcai2018-gradual-verification.pdf" style="color: #364491; border-bottom:1px dotted">Gradual Verification</a>?

【<a href="https://blog.jpramos.me" style="color: #8B0000; text-align: right">main blog</a>】

<br>

## Background
---
> The following information is in part brought to you by my mentor <a href="https://www.cs.cmu.edu/~jlwise/" style="color: #364491; border-bottom:1px dotted">Jenna Wise</a> during my summer internship at Carnegie Mellon University. 

<br>

### What is verification?
Programmers encounter a lot of bugs during the software development. This is expected, we all know that whatever program we are developing it is most likely to error out. One might naïvely believe that the more seasoned a programmer is, the less errors they'll encounter, no more syntax errors, no more null pointer exceptions! However, a seasoned programmer actually becomes so good at unintentionally developing bugs, that the program won't even tell you when there's an error, the program will seem superficially *sound*, when it in fact is not. The best way to solve this is by writing *unit tests*. Manually developing test cases for a given program, whether you want to take advantage of Testing Driven Development (TDD), or are forced to do so for your undergraduate intro Java course, can become not just annoying, but incredibly non-exhaustive. The subjective *positives* of unit tests, such as TDD, can still be taken advantage of outside of manually writing tests! This can be given through a specification, similar to <a href="https://en.wikipedia.org/wiki/Black-box_testing" style="color: #364491; border-bottom:1px dotted">black box testing</a>. But get this, the specification isn't for the programmer, it's for a *verifier* that will take advantage of the specification, and **check** that your code follows that given specification. Of course, at least ignoring Machine Learning and Program Synthesis research, a computer can't intuitively parse human black box or glass box techniques. Developing these specifications is what's known as a **Formal Method**.

<br>

### Formal verification
Specifications are written in some logic-based language that makes it easier to express properties the developer cares about. An example of this is <a href="https://en.wikipedia.org/wiki/Hoare_logic" style="color: #364491; border-bottom:1px dotted">Hoare logic</a>. Here is a simple example for ensuring that the amount of money in someone's bank account can't become negative when withdrawing from that bank account.

```c
int withdraw ( int amount )
  requires this.balance >= amount // P: PRECONDITION
  ensures this.balance >= 0 // Q: POSTCONDITION
{
  this.balance := this.balance - amount;
}
```
> Annotated method (A-1)
#### Static verification
This is a verification technique that operates at compile-time. For example, the verifier can ensure that for every call to withdraw that adheres to its precondition withdraw's implementation **will never produce a negative balance**.
- <u>Pros</u>: It provides early and comprehensive feedback to the programmer about errors in an implementation. 
- <u>Cons</u>: Tools require detailed annotations to make such strong guarantees.

```c
a := new Account();
a.balance := 100;
a.balance = 100 // Verifier can figure out `a.balance = 100` here
  P : a.balance >= 30 // The verifier knows this is true due to `a.balance = 100`
a.withdraw(30);
  Q : a.balance >= 0 // Then, the verifier learns only the postcondition
```
> Client Program to Verify

#### Dynamic verification
Unlike static verification, DV operates at run time. 

- <u>Pros</u>: Specifications only need to contain the property a programmer wants to verify. We do not have to be as detailed, because the verifier can leverage run-time information.
- <u>Cons</u>: Specs are only verified for **a single execution**: the pre- and postcondition of withdraw must be verified every time withdraw is called. **This is what we call a runtime check, which requires more computation**.

```c
a := new Account();
a.balance := 100;

assert P: a.balance >= 30 // Check here
a.withdraw(30);
assert Q: a.balance >= 0 // Passes because a.balance = 70 

// The assert will pass, because a.balance = 70 here at run time. In static verification, we could only know the postcondition a.balance >= 0, so this assert would fail a static verifier.
assert a.balance = 70
```
> Client Program to Verify (Dynamic)

<br>

## Advanced Static Verification
---
> This section quickly details at a more technical level (but still very accessible) the ideas behind static verification. It's not necessary to understand the *Gradualness* I'll talk about later.

<br>

### Preconditions & Postconditions
We use pre- and postconditions to specify the behavior of methods and prove that the behavior we claim of the method is true.

- <u>Postcondition</u>: Something that is true after the method returns and is declared with the `ensures` keyword. The keyword is followed by a formula that can be true or false expressed in the spec language. When the expression is true, we can say that the postcondition holds.
- <u>Precondition</u>: Something that must be true before a method is called. When you call a method, it is your job to establish the precondition, and the static verifier enforces it using a *proof*. When you write a method's body, you get to assume the precondition, but you must establish the postcondition (*the verifier will try to prove the postcondition and you have to make sure it can by giving correct specs and implementation*). The caller of the method t hen gets to assume that the postcondition holds after the method returns. Not all methods necessarily have preconditions. Preconditions have their own keyword, `requires`.

<br>

### Loop invariants
To make it possible for verifiers to work with loops, you ned to provide loop invariants. A **loop invariant** is an expression that holds upon entering a loop, and after every execution of the loop body (including the last one when the loop condition is false). It captures a property that is invariant, i.e. does not change, about every step of the loop.

<br>

## The Frame Problem 
---
> For more details on the Frame Problem, read <a href="http://www.cs.cmu.edu/~aldrich/courses/17-355-19sp/resources/recitation09-notes.pdf" style="color: #364491; border-bottom:1px dotted">these lecture notes</a>.

<br>

Consider this program written in <a href="https://en.wikipedia.org/wiki/Dafny" style="color: #364491; border-bottom:1px dotted">Dafny</a>:

```c
class Cell {
  var contents: int;

  method Init()
    ensures contents == 1;
    {
      contents := 1;
    }

    method setContents(x: int)
      ensures contents == x;
    {
      contents := x;
    }
}

method TestCell() {
  var c1 := new Cell;
  var c2 := new Cell;
  c1.Init();
  c2.Init();

  c1.setContents(4);

  assert c1.contents == 4;
  assert c2.contents == 1;
}
```
**This program will not verify correctly in Dafny, because we do not provide specifications that allow us to solve "The Frame Problem".** In particular, `TestCell()` calls `c1.setContents(4)`, the `setContents` method's specification makes no indication of what else may happen to the program state during the execution of `c1.setContents(4)` other than assigning `c1.contents` to `4`. Therefore, the **specification is too weak** to say that `c2.contents` has not changed and is still equal to 1 after the call to `c1.setContents(4)`.

In other words, the problem can be states as follows:
*When formally describing a change in a system, how do we specify what parts of the state of the system are not affected by that change?*

<br>

## A Solution to the Frame Problem
---
> The possible solutions towards the frame problem are very complicated and could have blogposts dedicated to themseleves. Therefore, I'll only give a brief explanation of what these solutions provide and a link for your own further reading.

<br>

### <a href="https://cacm.acm.org/magazines/2019/2/234356-separation-logic/fulltext" style="color: #364491; border-bottom:1px dotted">Separation logic</a>
This technique seeks to extend Hoare logic with an operator called the *separating conjunction*, usually noted as either `*` or `&&`.

![Picture Semantics](data/separation.png)

These *picture semantics* are introduced by Peter O'Hearn to visually describe what's happening with the separating conjunction:
> The indicated separating conjunction here is true of the pictured memory because the parts satisfy the conjuncts, as indicated in the second picture. The meaning of "x points to y and yet to nothing" is precisely disambiguated in the RAM description below the diagram: x and y denote values (10 and 42), x's value is an allocated memory address which contains y's value, but y's value is not allocated. The separating conjunction splits the heap/RAM, but it does not split the association of variables to values.

<br>

### <a href="http://viper.ethz.ch/tutorial/#expressions-and-assertions" style="color: #364491; border-bottom:1px dotted">Implicit Dynamic Frames</a>
As stated by <a href="https://dl.acm.org/doi/10.1145/2160910.2160911" style="color: #364491; border-bottom:1px dotted">Smans et al. [2012]</a>, 

<br>

<br>

<br>

【<a href="https://blog.jpramos.me" style="color: #8B0000; text-align: right">main blog</a>】
